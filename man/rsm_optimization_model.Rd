% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/brsmatching.R
\name{rsm_optimization_model}
\alias{rsm_optimization_model}
\title{Build optimization model for Balanced Risk Set Matching}
\usage{
rsm_optimization_model(
  n_pairs,
  edges,
  bal_all = NULL,
  optimizer = "gurobi",
  verbose = FALSE,
  balance = TRUE
)
}
\arguments{
\item{n_pairs}{number of pairs desired from matching}

\item{edges}{data frame with columns "trt_id", "all_id", "trt_time", "dist";
for example, the output from a call to \code{compute_distances()}}

\item{bal_all}{matrix with columns "id", "time", and additional balance
columns; for example, the output from a call to \code{balance_columns()};
defaults to NULL, indicating balance is not used.}

\item{optimizer}{"gurobi" or "glpk". Specifies which optimizer output to use;
defaults to "gurobi".}

\item{verbose}{logical; if TRUE, will print some useful information for
potentially long model calls; defaults to FALSE}

\item{balance}{When TRUE, a balanced risk set matching model will be built.
When FALSE, or when bal_all = NULL, balancing constraints will not be
included.}
}
\value{
an optimization model that can be readily passed to the optimizer
parameter.  Defines the mixed integer programming problem for risk set
matching in terms of specified data.
}
\description{
The \code{rsm_optimization_model} function takes in a distance data-frame
(tidy-format) and optional balancing columns and returns an optimization
model in the corresponding optimizer format.  The model is build to generate
\code{n_pairs} pairs that minimize the distance while ensuring that each id
gets used in at most one pair.  If \code{balance} is TRUE, the optimization
model will also add constraint variables that heavily penalize violations
of the balance criterion.  This function is rarely useful on its own, it
is preferred to make a function call to \code{brsmatch}.
}
\examples{
df <- data.frame(
  hhidpn = rep(1:3, each = 3),
  wave = rep(1:3, 3),
  treatment_time = rep(c(2,3,NA), each = 3),
  X1 = c(2,2,2,3,3,3,9,9,9),
  X2 = rep(c("a","a","b"), each = 3),
  X3 = c(9,4,5,6,7,2,3,4,8),
  X4 = c(8,9,4,5,6,7,2,3,4)
)
edges <- compute_distances(df, "hhidpn", "wave", "treatment_time")
bal <- balance_columns(df, "hhidpn", "wave", "treatment_time")
n_unique_id <- length(unique(df$hhidpn))

model <- rsm_optimization_model(1, edges, bal, optimizer = "gurobi", balance = TRUE)

}
